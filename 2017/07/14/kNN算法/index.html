<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="googleb849f8ce9353f945.html" />













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="欢迎戳进" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="1、knn?k-近邻算法采用测量不同特征值之间距离的方法进行分类.思想很简单：如果一个样本的特征空间中最为临近（欧式距离进行判断）的K个点大都属于某一个类，那么该样本就属于这个类。这就是物以类聚的思想。">
<meta property="og:type" content="article">
<meta property="og:title" content="kNN算法">
<meta property="og:url" content="http://yoursite.com/2017/07/14/kNN算法/index.html">
<meta property="og:site_name" content="唐相儒的博客">
<meta property="og:description" content="1、knn?k-近邻算法采用测量不同特征值之间距离的方法进行分类.思想很简单：如果一个样本的特征空间中最为临近（欧式距离进行判断）的K个点大都属于某一个类，那么该样本就属于这个类。这就是物以类聚的思想。">
<meta property="og:image" content="http://img.blog.csdn.net/20170202231135387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXJ0cHJvZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170202231418559?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXJ0cHJvZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2017-07-14T04:55:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kNN算法">
<meta name="twitter:description" content="1、knn?k-近邻算法采用测量不同特征值之间距离的方法进行分类.思想很简单：如果一个样本的特征空间中最为临近（欧式距离进行判断）的K个点大都属于某一个类，那么该样本就属于这个类。这就是物以类聚的思想。">
<meta name="twitter:image" content="http://img.blog.csdn.net/20170202231135387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXJ0cHJvZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/14/kNN算法/"/>





  <title> kNN算法 | 唐相儒的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">唐相儒的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/首页" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-ban"></i> <br />
            
            博客首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-hand-peace-o"></i> <br />
            
            文章分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/目录" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            文章归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/标签" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sign-language"></i> <br />
            
            文章标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-map-o"></i> <br />
            
            导航
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-asl-interpreting"></i> <br />
            
            team
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/14/kNN算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐相儒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://ooo.0o0.ooo/2017/07/01/59575381605d5.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐相儒的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                kNN算法
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-14T11:30:56+08:00">
                2017-07-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/14/kNN算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/07/14/kNN算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1、knn"><a href="#1、knn" class="headerlink" title="1、knn?"></a>1、knn?</h1><p>k-近邻算法采用测量不同特征值之间距离的方法进行分类.思想很简单：如果一个样本的特征空间中最为临近（欧式距离进行判断）的K个点大都属于某一个类，那么该样本就属于这个类。这就是物以类聚的思想。<br><a id="more"></a><br>优点：精度高、对异常值不敏感、无数据输入假定<br>缺点：计算复杂度高、空间复杂度高<br>适用数据范围：数值型和标称型</p>
<p>通过计算新数据与训练数据特征值之间的距离，然后选取K（K&gt;=1）个距离最近的进行分类判断</p>
<h2 id="1-1-关键"><a href="#1-1-关键" class="headerlink" title="1.1 关键"></a>1.1 关键</h2><p>1、数据的所有特征都要做可比较的量化。<br>若是数据特征中存在非数值的类型，必须采取手段将其量化为数值。另外，样本有多个参数，每一个参数都有自己的定义域和取值范围，他们对distance计算的影响也就不一样，so样本参数必须做一些scale处理，usually所有特征的数值都采取归一化处置。</p>
<p>2、需要一个distance函数以计算两个样本之间的距离。<br>距离的定义有很多，如欧氏距离、余弦距离、汉明距离、曼哈顿距离等等.about相似性度量的方法可参考‘漫谈：机器学习中距离和相似性度量方法’。usually选欧氏距离作为距离度量，但是这是只适用于连续变量。在文本分类这种非连续变量情况下，汉明距离可以用来作为度量。btw，如果运用一些特殊的算法来计算度量的话，K近邻分类精度可显著提高，如运用大边缘最近邻法或者近邻成分分析法。</p>
<p>3，确定K的值<br>K是一个自定义的常数，K的值也直接影响最后的估计，一种选择K值得方法是使用 cross-validate（交叉验证）误差统计选择法(就是数据样本的一部分作为训练样本，一部分作为测试样本，比如选择95%作为训练样本，剩下的用作测试样本。)通过训练数据训练一个机器学习模型，然后利用测试数据测试其误差率。 cross-validate（交叉验证）误差统计选择法就是比较不同K值时的交叉验证平均误差率，选择误差率最小的那个K值。例如选择K=1,2,3,… ，   对每个K=i做100次交叉验证，计算出平均误差，然后比较、选出最小的那个。</p>
<h1 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h1><p>存在一个样本数据集合（知道所属的对应分类）。输入没有标签的数据后，将这个没有标签的数据的每个特征与样本集中的数据对应的特征进行比较，然后算法提取样本中特征最相似的数据（最邻近）的分类标签。我们只选择样本数据集中前 k 个最相似的数据，通常 k 是不大于 20 的整数。最后，选择 k 个最相似数据中出现次数最多的类别，作为新数据的分类。</p>
<h2 id="3-1机器学习实战上的电影例子"><a href="#3-1机器学习实战上的电影例子" class="headerlink" title="3.1机器学习实战上的电影例子"></a>3.1机器学习实战上的电影例子</h2><p>用 K-近邻算法来分来爱情片和动作片</p>
<p>即使不知道未知电影属于哪种类型，我们也可以通过某种方法计算出来。首先要计算未知电影与样本集中其他电影的距离，计算方法很简单，即欧式空间距离(Euclidean Distance)</p>
<p>现在我们得到了样本集中所有电影与未知电影的距离，按照距离递增排序，可以找到 k 个距离最近的电影，例如 k=3</p>
<p>K-近邻算法按照距离最近的三部电影的类型，决定未知电影的类型，而这三部电影全是爱情片，因此我们判定未知电影是爱情片。</p>
<h2 id="3-2knn流程"><a href="#3-2knn流程" class="headerlink" title="3.2knn流程"></a>3.2knn流程</h2><p>距离计算所需要的值，最好是结构化的数据。</p>
<p>KNN算法的过程为:<br>选择一种距离计算方式, 通过数据所有的特征计算新数据与已知类别数据集中的数据点的距离<br>按照距离递增次序进行排序，选取与当前距离最小的k个点<br>对于离散分类，返回k个点出现频率最多的类别作预测分类；对于回归则返回k个点的加权值作为预测值</p>
<p>使用算法：首先需要输入样本数据和待分类数据，然后运行k-近邻算法判定待分类数据分别属于哪个分类，最后应用计算出的分类执行后续的处理</p>
<h1 id="4-python实现knn"><a href="#4-python实现knn" class="headerlink" title="4.python实现knn"></a>4.python实现knn</h1><h2 id="4-1python导入数据"><a href="#4-1python导入数据" class="headerlink" title="4.1python导入数据"></a>4.1python导入数据</h2><p>将下面的代码保存到名为 kNN.py 的文本文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">from numpy import *</div><div class="line"></div><div class="line">def createDataSet():</div><div class="line">dataSet = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) # 创建一个2x2的数组</div><div class="line">labels = [&apos;A&apos;, &apos;A&apos;, &apos;B&apos;, &apos;B&apos;] # 创建一个长度为4的列表</div><div class="line">return dataSet, labels</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;&gt;&gt; import kNN</div><div class="line">&gt;&gt;&gt; group,labels=kNN.createDataSet()</div><div class="line">&gt;&gt;&gt; kNN.classify0([0,0],group,labels,3)</div></pre></td></tr></table></figure>
<h2 id="4-2实现knn"><a href="#4-2实现knn" class="headerlink" title="4.2实现knn"></a>4.2实现knn</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">from operator import itemgetter</div><div class="line"># inVec为待分类向量，dataSet和labels为数据集，k是最近点的个数</div><div class="line">def classify0(inVec, dataSet, labels, k):</div><div class="line">numberOfLines = dataSet.shape[0] # 获得数据集样本数量</div><div class="line"></div><div class="line">diffMat = tile(inVec, (numberOfLines, 1)) - dataSet # 将数据集中每个点都与待分类点相减，即各个特征相减</div><div class="line">squareDiffMat = diffMat**2 # 求差的平方</div><div class="line">squareDistance = squareDiffMat.sum(axis=1) # 求差的平方的和</div><div class="line">distances = squareDistance**0.5 # 对平方和开方得到距离</div><div class="line"></div><div class="line"># 对距离进行排序，argsort()函数默认按升序排列，但只返回下标，不对原数组排序</div><div class="line">sortedDistIndicies = distances.argsort()</div><div class="line">classCount = &#123;&#125; # 用于保存各个类别出现的次数</div><div class="line"></div><div class="line">for i in range(k): # 统计最近的 k 个点的类别出现的次数</div><div class="line">label = labels[sortedDistIndicies[i]]</div><div class="line">classCount[label] = classCount.get(label, 0) + 1</div><div class="line"></div><div class="line"># 对类别出现的次数进行排序，sorted()函数默认升序</div><div class="line">sortedClassCount = sorted(classCount.iteritems(), key=itemgetter(1), reverse=True)</div><div class="line">return sortedClassCount[0][0] # 返回类别出现次数最多的分类名称</div></pre></td></tr></table></figure>
<p>1、shape()函数：返回数组的尺寸信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = tile((1,2),(3,2))</div><div class="line">&gt;&gt;&gt; x.shape[0]</div></pre></td></tr></table></figure></p>
<p>2、tile()函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; tile([1,2],(3,2))</div></pre></td></tr></table></figure></p>
<p>3、sum()函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = tile((1,2),(3,2))</div><div class="line">&gt;&gt;&gt; x</div><div class="line">array([[1, 2, 1, 2],</div><div class="line">       [1, 2, 1, 2],</div><div class="line">       [1, 2, 1, 2]])</div><div class="line">&gt;&gt;&gt; x.sum(axis=0)</div><div class="line">array([3, 6, 3, 6])</div><div class="line">&gt;&gt;&gt; x.sum(axis=1)</div></pre></td></tr></table></figure></p>
<p>4、argsort()函数，返回排序后的原来位置的索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; v = [1, 4, 2, 3]</div><div class="line">&gt;&gt;&gt; argsort(v)</div></pre></td></tr></table></figure></p>
<p>5、sorted()函数，按参数 key 排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123;&apos;a&apos;:2,&apos;b&apos;:1,&apos;c&apos;:6,&apos;d&apos;:-2&#125;</div><div class="line">&gt;&gt;&gt; d</div><div class="line">&#123;&apos;a&apos;: 2, &apos;c&apos;: 6, &apos;b&apos;: 1, &apos;d&apos;: -2&#125;</div><div class="line">&gt;&gt;&gt; from operator import itemgetter</div><div class="line">&gt;&gt;&gt; sorted(d.iteritems(),key=itemgetter(1),reverse=True)</div><div class="line">```		</div><div class="line">## 4.3测试分类器</div><div class="line"></div><div class="line"># 5.knn改进配对算法</div><div class="line"></div><div class="line">## 5.1从文本中解析数据</div></pre></td></tr></table></figure></p>
<p>def file2matrix(filename):<br>    f = open(filename) # 打开文件<br>    dataSet = f.readlines() # 读取文件的全部内容<br>    numberOfLines = len(dataSet) # 获得数据集的行数<br>    returnMat = zeros((numberOfLines, 3)) # 创建一个初始值为0，大小为 numberOfLines x 3 的数组<br>    classLabelVector = [] # 用于保存没个数据的类别标签<br>    index = 0<br>    for line in dataSet: # 处理每一行数据<br>        line = line.strip() # 去掉行首尾的空白字符,(包括’\n’, ‘\r’,  ‘\t’,  ‘ ‘)<br>        listFromLine = line.split() # 分割每行数据，保存到一个列表中<br>        returnMat[index, :] = listFromLine[0:3] # 将列表中的特征保存到reurnMat中<br>        classLabelVector.append(int(listFromLine[-1])) # 保存分类标签<br>        index += 1<br>    return returnMat, classLabelVector<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">&gt;&gt;&gt; reload(kNN)</div><div class="line"> &gt;&gt;&gt; datingDataMat, datingLabels = kNN.file2matrix(&apos;datingTestSet2.txt&apos;)</div></pre></td></tr></table></figure></p>
<h2 id="5-2分析数据"><a href="#5-2分析数据" class="headerlink" title="5.2分析数据"></a>5.2分析数据</h2><p>使用 Matplotlib 创建散点图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import matplotlib</div><div class="line">&gt;&gt;&gt; import matplotlib.pyplot as plt</div><div class="line">&gt;&gt;&gt; fig = plt.figure()</div><div class="line">&gt;&gt;&gt; ax = fig.add_subplot(111)</div><div class="line">&gt;&gt;&gt; ax.scatter(datingDataMat[:,1], datingDataMat[:,2])</div><div class="line">&gt;&gt;&gt; plt.show()</div></pre></td></tr></table></figure></p>
<p>Matplotlib 库提供的 scatter 函数支持个性化标记散点图上的点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from numpy import *</div><div class="line">&gt;&gt;&gt; fig = plt.figure()</div><div class="line">&gt;&gt;&gt; ax = fig.add_subplot(111)</div><div class="line">&gt;&gt;&gt; ax.scatter(datingDataMat[:,1],datingDataMat[:,2],15.0*array(datingLabels),15.0*array(datingLabels))</div><div class="line">&gt;&gt;&gt; plt.show()</div></pre></td></tr></table></figure></p>
<p>将每年获得的飞行常客里程数作为 x 轴，玩视频游戏所耗时间百分比作为 y 轴<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; fig = plt.figure()</div><div class="line">&gt;&gt;&gt; ax = fig.add_subplot(111)</div><div class="line">&gt;&gt;&gt; ax.scatter(datingDataMat[:,0],datingDataMat[:,1],15.0*array(datingLabels),15.0*array(datingLabels))</div><div class="line">&gt;&gt;&gt; plt.show()</div></pre></td></tr></table></figure></p>
<p>另外，为了方便画图，不用每次都输入上面几行代码，我们可以写一个函数 showPlots 来完成同样的功能(将代码添加到 kNN.py 中)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from numpy import *</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line">def showPlots(x, y, labels): # x:x轴数据，y:轴数据，labels:分类标签数据</div><div class="line">fig = plt.figure()</div><div class="line">ax = fig.add_subplot(111)</div><div class="line">ax.scatter(x ,y, 15.0*array(labels), 15*array(labels))</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>重新载入 kNN.py ，输入如下代码即可画图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; reload(kNN)</div><div class="line">&gt;&gt;&gt; kNN.showPlots(datingDataMat[:,0], datingDataMat[:,1], datingLabels)</div></pre></td></tr></table></figure></p>
<h2 id="5-3归一化"><a href="#5-3归一化" class="headerlink" title="5.3归一化"></a>5.3归一化</h2><p>处理这种不同取值范围的特征值时，我们需要对数据进行归一化处理(权重一样，但是数值范围不同）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">def autoNorm(dataSet):</div><div class="line">minVals = dataSet.min(0) # minVals保存每列最小值</div><div class="line">maxVals = dataSet.max(0) # maxVals保存每列最大值</div><div class="line">ranges = maxVals - minVals # ranges保存每列的取值范围</div><div class="line">normedDataSet = zeros(shape(dataSet))</div><div class="line">numberOfLines = dataSet.shape[0]</div><div class="line">normedDataSet = dataSet - tile(minVals, (numberOfLines, 1))</div><div class="line">normedDataSet = normedDataSet / tile(ranges, (numberOfLines, 1))</div><div class="line">return normedDataSet, ranges, minVals</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; reload(kNN)</div><div class="line">&gt;&gt;&gt; normMat, ranges, minVals = kNN.autoNorm(datingDataMat)</div><div class="line">&gt;&gt;&gt; normMat</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="5-4测试"><a href="#5-4测试" class="headerlink" title="5.4测试"></a>5.4测试</h2><p>分类器的错误率=错误分类次数/分类测试总次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def datingClassTest():</div><div class="line">testRatio = 0.10 # 测试比例</div><div class="line">datingDataMat, datingLabels = file2matrix(&apos;datingTestSet2.txt&apos;) # 获得原始数据</div><div class="line">normedMat, ranges, minVals = autoNorm(datingDataMat) # 归一化</div><div class="line">m = normedMat.shape[0] # 原始数据行数</div><div class="line">numTestVecs = int(m*testRatio) # 测试数据行数</div><div class="line">errorCount = 0 # 错误分类计数器</div><div class="line">for i in range(numTestVecs): # 测试</div><div class="line">classifierResult = classify0(normedMat[i,:], </div><div class="line">normedMat[numTestVecs:m,:], datingLabels[numTestVecs:m], 4)</div><div class="line">print &quot;The classifier came back with: %d, the real answer is: %d&quot;\</div><div class="line">% (classifierResult, datingLabels[i])</div><div class="line">if(classifierResult != datingLabels[i]):</div><div class="line">errorCount += 1</div><div class="line">print &quot;The total error rate is: %f&quot; % (errorCount/float(numTestVecs))</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; reload(kNN)</div><div class="line">&gt;&gt;&gt; kNN.datingClassTest()</div></pre></td></tr></table></figure>
<h2 id="5-5完整系统"><a href="#5-5完整系统" class="headerlink" title="5.5完整系统"></a>5.5完整系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def classifyPerson():</div><div class="line">resultList = [&apos;not at all&apos;, &apos;in small doses&apos;, &apos;in large doses&apos;]</div><div class="line">percentTime = float(raw_input(&quot;percentage of time spent playing video games: &quot;))</div><div class="line">ffMiles = float(raw_input(&quot;frequent flier miles earned per year: &quot;))</div><div class="line">iceCream = float(raw_input(&quot;liters of ice cream consumed per year: &quot;))</div><div class="line">datingDataMat, datingLabels = file2matrix(&apos;datingTestSet2.txt&apos;)</div><div class="line">normedMat, ranges, minVals = autoNorm(datingDataMat)</div><div class="line">inVec = array([ffMiles, percentTime, iceCream])</div><div class="line">classifierResult = classify0((inVec-minVals)/ranges, normedMat, datingLabels, 4)</div><div class="line">print &quot;You will probably like this person&quot;, resultList[classifierResult-1]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; reload(kNN)</div><div class="line">&gt;&gt;&gt; kNN.classifyPerson()</div></pre></td></tr></table></figure>
<h1 id="6-手写识别系统"><a href="#6-手写识别系统" class="headerlink" title="6.手写识别系统"></a>6.手写识别系统</h1><p>书本配备了两个数据集，一个是存储在文件夹 trainingDigits 内的训练集，大约2000个样本；另一个是存储在 testDigits 文件夹内的测试集，大约900个样本。如下图所示。两组数据没有重叠，尺寸均为 32行 x 32列。<br><img src="http://img.blog.csdn.net/20170202231135387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXJ0cHJvZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>文件夹 trainingDigits 和文件夹 testDigits 的内容都是如下形式的样列：<br><img src="http://img.blog.csdn.net/20170202231418559?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXJ0cHJvZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>将 32x32 的文本处理为一个尺寸为 1x1024 向量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def img2vector(filename):</div><div class="line">returnVec = zeros((1,1024)) # 用于保存1x1024的向量</div><div class="line">f = open(filename) # 打开文件</div><div class="line">for i in range(32): # 读取每一行并转换为1x1024的向量</div><div class="line">lineStr = f.readline()</div><div class="line">for j in range(32): # 处理第i行j列的一个字符</div><div class="line">returnVec[0,32*i+j] = int(lineStr[j]) # 字符需要强制类型转换成整数</div><div class="line">return returnVec</div></pre></td></tr></table></figure></p>
<p>检查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; reload(kNN)</div><div class="line">&gt;&gt;&gt; testVec = kNN.img2vector(&apos;testDigits/0_13.txt&apos;)</div><div class="line">&gt;&gt;&gt; testVec</div><div class="line">array([[ 0.,  0.,  0., ...,  0.,  0.,  0.]])</div><div class="line">&gt;&gt;&gt; testVec[0,0:32]</div></pre></td></tr></table></figure></p>
<h2 id="6-2-测试算法"><a href="#6-2-测试算法" class="headerlink" title="6.2 测试算法"></a>6.2 测试算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">from os import listdir</div><div class="line">def handwritingClassTest():</div><div class="line">print &quot;Loading data...&quot;</div><div class="line">hwLabels = [] # 保存手写数字的分类标签</div><div class="line">trainingFileList = listdir(&apos;trainingDigits&apos;) # 得到文件夹trainingDigits下的所有文件名</div><div class="line">m = len(trainingFileList) # 训练集样本的个数</div><div class="line">trainingMat = zeros((m, 1024)) # 保存训练集</div><div class="line">for i in range(m):</div><div class="line">filenameStr = trainingFileList[i] # 得到文件名</div><div class="line">classNum = int(filenameStr.split(&apos;_&apos;)[0]) # 得到样本的分类标签</div><div class="line">hwLabels.append(classNum)</div><div class="line">trainingMat[i,:] = img2vector(&apos;trainingDigits/%s&apos; % filenameStr)</div><div class="line">testFileList = listdir(&apos;testDigits&apos;) # 得到文件夹testDigits下的所有文件名</div><div class="line">errorCount = 0 # 错误分类计数器</div><div class="line">mTest = len(testFileList) # 测试集样本个数</div><div class="line">for i in range(mTest): # 开始测试</div><div class="line">filenameStr = testFileList[i]</div><div class="line">classNum = int(filenameStr.split(&apos;_&apos;)[0])</div><div class="line">testVect = img2vector(&apos;trainingDigits/%s&apos; % filenameStr)</div><div class="line">classifierResult = classify0(testVect, trainingMat, hwLabels, 3)</div><div class="line">print &quot;The classifier came back with: %d, the real answer is: %d&quot;\</div><div class="line">% (classifierResult, classNum)</div><div class="line">if(classifierResult != classNum):</div><div class="line">errorCount += 1</div><div class="line">print &quot;The total number of errors is: %d&quot; % errorCount</div><div class="line">print &quot;The total error rate is: %f&quot; % (errorCount/float(mTest))</div></pre></td></tr></table></figure>
<p>输入下面的命令对分类器进行测试（k=3）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; reload(kNN)</div><div class="line">&gt;&gt;&gt; kNN.handwritingClassTest()</div></pre></td></tr></table></figure></p>
<p>如果选择最近的一个作为分类标签，那么准确率会非常的高：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; reload(kNN)</div><div class="line">&lt;module &apos;kNN&apos; from &apos;kNN.pyc&apos;&gt;</div><div class="line">&gt;&gt;&gt; kNN.handwritingClassTest()</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、kNN缺陷是无法给出任何数据的基础结构信息。而决策树能够解决这个问题，并且速度很快。<br>2、另一个缺点就是既占空间速度又慢</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/05/unique-summer-lab-0的书签/" rel="next" title="unique_summer_lab_0的书签">
                <i class="fa fa-chevron-left"></i> unique_summer_lab_0的书签
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/14/kd-tree/" rel="prev" title="kd tree">
                kd tree <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://ooo.0o0.ooo/2017/07/01/59575381605d5.png"
               alt="唐相儒" />
          <p class="site-author-name" itemprop="name">唐相儒</p>
           
              <p class="site-description motion-element" itemprop="description">Never Let Your Fear Decide Your Future</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/目录">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、knn"><span class="nav-number">1.</span> <span class="nav-text">1、knn?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-关键"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 关键</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、原理"><span class="nav-number">2.</span> <span class="nav-text">2、原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1机器学习实战上的电影例子"><span class="nav-number">2.1.</span> <span class="nav-text">3.1机器学习实战上的电影例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2knn流程"><span class="nav-number">2.2.</span> <span class="nav-text">3.2knn流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-python实现knn"><span class="nav-number">3.</span> <span class="nav-text">4.python实现knn</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1python导入数据"><span class="nav-number">3.1.</span> <span class="nav-text">4.1python导入数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2实现knn"><span class="nav-number">3.2.</span> <span class="nav-text">4.2实现knn</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2分析数据"><span class="nav-number">3.3.</span> <span class="nav-text">5.2分析数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3归一化"><span class="nav-number">3.4.</span> <span class="nav-text">5.3归一化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4测试"><span class="nav-number">3.5.</span> <span class="nav-text">5.4测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5完整系统"><span class="nav-number">3.6.</span> <span class="nav-text">5.5完整系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-手写识别系统"><span class="nav-number">4.</span> <span class="nav-text">6.手写识别系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-测试算法"><span class="nav-number">4.1.</span> <span class="nav-text">6.2 测试算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">唐相儒</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/07/14/kNN算法/';
          this.page.identifier = '2017/07/14/kNN算法/';
          this.page.title = 'kNN算法';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  





  






  





  

  

  

  





</body>
</html>
